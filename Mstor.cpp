/* SYSTEM REQUIREMENTS:												*/
/* MSTOR requires that your system have a regularly occurring 2-25ms interrupt service routine (isr) which calls  		*/
/* the MSTOR.run_ms_timer(). If your application does not have one, UNcomment define CREATE_ISR_TIMER	below			*/
/*
Written:	12/11/22
Author:		John Ursoleo/Versalent
Name: 		mstor.cpp
Purpose:	provide an easy-to-use driver for Mstor to integrate into Arduino
Description:  This module provides the basic functions needed to communicate with Versalent's Mstor
			which is an SPI-to_USB drive interface adapter.  THis software provides a simple mailbox
			for communications

Version:	1.00
Features:	Initial release
Date:		12/11/22
*/

// ****************************************  DO NOT EDIT THIS FILE  *********************************************
// ****************************************  DO NOT EDIT THIS FILE  *********************************************


#include "Arduino.h"
#include "mstor.h"
#include <MsTimer2.h>
#include <SoftwareSerial.h>
#include "Mstorcfg.h"
#include <HardwareSerial.h>


//Public methods
// *********************************************************
//Constructor
Mstor::Mstor()
{
	timeout_ms = MSTOR_TIMEOUT;		//default value to start
	_ms_per_tick = MS_PER_TICK;		//the rate of the Timer ISR
}

/*

//add framing to the array, but do it in-place so dont have to allocate another large buffer for it
void Mstor::build_cmd_block(unsigned char * blk, unsigned char * count)
{
	byte i;
	unsigned int crc;

	//shift the entire array right by 2 positions to make room for <C  framing characters
	for (i=*count;i>0;i--) blk[i+1] = blk[i-1];
	blk[0] = '<';					//insert framing char
	blk[1] = *count;				//insert data byte count NOT full block count
	crc = compute_crc(blk, *count);
	*count = *count + 5;			//increase block count to +5 larger then unframed
	blk[*count -3] = crc >> 8;		//insert crc HIGH
	blk[*count -2] = crc & 0xff;	//insert crc LOW
	blk[*count -1] = '>';			//insert framing char
} */

//open a file in the specified mode  R/W/A
unsigned char Mstor::fileOpen(char mode, char * filename)
{
	 unsigned char result = NO_ERROR;
	 char mstor_cmd[MAX_CMD_LENGTH];				//mstor command string can be this long max
	 mstor_cmd[0] = mode;							//R=read. W=write, A=append
	 mstor_cmd[1] = 0;								//null terminator so it is a string
	 strcat(mstor_cmd, filename);					//combine with filename
	 strcat(mstor_cmd, "\r");
	 result = execute_command(mstor_cmd, NOTIFY);		//send this string to mstor, notify host of result
	 return result;
}

//open a file in SEEK mode... same as Read except includes an offset
unsigned char Mstor::fileSeek(char * filename, unsigned long loffset)	//command is  filename,offset .. offset is a long
{
	 unsigned char result = NO_ERROR;
	 char offset_str[9];
	 char mstor_cmd[MAX_CMD_LENGTH];				//mstor command string can be this long max
	 strcpy(mstor_cmd, "S");						//S is the Mstor seek command
	 strcat(mstor_cmd, filename);					//combine with filename
	 strcat(mstor_cmd,">");							//the separator that Mstor wants
	 ultoa(loffset, offset_str, 10);				//convert the long to a decimal string -- for Mstor
	 strcat(mstor_cmd, offset_str);					//tack on the offset string
	 strcat(mstor_cmd, "\r");						//end the command with {CR}
	 result = execute_command(mstor_cmd, NOTIFY);		//send this string to mstor, notify host of result
	 return result;
}

//read a single record from the file already opened in READ or Seek mode. Data is returned in the Mstor.data[] array and the number of bytes
//is in Mstor.data_count.  When a zero-length record is received, there is no more data. Records are retrieved with get_packet() which
//validates the received record. On failure that function re-requests the same packet by issuing 'rp'  (read-previous)  up to 4 times
//in a row before throwing in the towel and returning an error
unsigned char Mstor::fileRead()
{
  unsigned char result;
  char scmd[4];

  strcpy(scmd, "rn\r");									//send the 'r' command with 'n'ext to return next record from a file already opened
  result = execute_command(scmd, NOTIFY);				//with the 'fileOpen function, READ mode
  return result;
  }

//write a single record to the file already opened in WRITE or APPEND mode. Data is in the Mstor.data[] array and the number of bytes
//is in Mstor.data_count.  (When there is no more data to send, send one final zero-record)
unsigned char Mstor::fileWrite(char * wstring)		//write this string to the open file
{
  unsigned char result;
  char scmd[MAX_CMD_LENGTH + 6];
  if (strlen(wstring) == 0 || strlen(wstring) > 45)		//check that the strlen is within bounds
     return INVALID_PARAMETER;							//return this error if not
  strcpy(scmd, "w");									//send the 'w' command to write  one record to the file already opened
  strcat(scmd, wstring);								//user writting a string to the open file
  strcat(scmd, "\r");
  result = execute_command(scmd, NOTIFY);				//with the 'fileOpen function, WRITE/APPEND mode
  return result;
  }

  //write a single record to the file already opened in WRITE or APPEND mode. Data is in the Mstor.data[] array and the number of bytes
  //is in Mstor.data_count.  (When there is no more data to send, send one final zero-record)
  unsigned char Mstor::fileWrite()						//write this array to the open file
  {
    unsigned char result;
    char cmd;
    unsigned char i;

    	cmd = 'w';									//send the 'w' command to write  one record to the file already opened
    	for (i=0;i<3;i++)							//try this comnad up to 3 times before returning a failure
    	{
	    	result = execute_command(cmd, data, data_count, NOTIFY);		//with the 'fileOpen function, WRITE/APPEND mode
	    	if (result == NO_ERROR) break;
		}
    return result;
    }

unsigned char Mstor::fileCopy(char * fromfile, char * tofile)
{
	 unsigned char result;
	 char scmd[48];
	 if (strlen(fromfile) + strlen(tofile) > 44) result = COMMAND_TOO_LONG;
	 else
	 {
	 	strcpy(scmd, "y");									//Mstor primitive command is "yFromfile>tofile" command to copy a file
	 	strcat(scmd, fromfile);
	 	strcat(scmd, ">");
	 	strcat(scmd, tofile);
	 	strcat(scmd, "\r");								//Mstor commands end with {CR} terminator
	 	//hexit((unsigned char *) scmd, strlen(scmd));
	 	result = execute_command(scmd, NOTIFY);				//generated by the 'y' command
	}
	 return result;
}

unsigned char Mstor::fileConcat(char * f1, char * f2, char * ftarg)
{
	 unsigned char result;
	 char scmd[50];
	 strcpy(scmd, "n");									//send the 'n' command to concatinate files
	 strcat(scmd, f1);
	 strcat(scmd,"+");
	 strcat(scmd, f2);
	 strcat(scmd, ">");
	 strcat(scmd, ftarg);
	 strcat(scmd, "\r");
	 result = execute_command(scmd, NOTIFY);				//generated by the 'y' command
	 return result;

}

//read a single file-or-dir list item.  Mstor has previously been send the L or D command to generate the list.
//Data is returned in Mstor.data[] and the number of bytes is in Mstor.data_count.  When a zero-length record is received,
//there is no more data
unsigned char Mstor::listRead()
{
  unsigned char result;
  char scmd[4];

  strcpy(scmd, "ln\r");									//send the 'l' command with 'n'ext param return next record from a list that has been
  result = execute_command(scmd, NOTIFY);				//generated by the 'L' command
  return result;
}


//close the open file (can only be one open at a time so close the one that is open)
unsigned char Mstor::fileClose()
{
	unsigned char result;
	char scmd[3];

	strcpy(scmd, "e\r");									//close the currently open file
	result = execute_command(scmd, NOTIFY);
	return result;
}

//close the open file (can only be one open at a time so close the one that is open)
unsigned char Mstor::mstorReset()
{
	unsigned char result;
	char scmd[3];

	strcpy(scmd, "X\r");									//close any currently open file, exit any mode .. back to command mode
	result = execute_command(scmd, NOTIFY);
	return result;
}

//overloaded fileList method that takes no parameters .. Mstor assumes *.* as mask
unsigned char Mstor::fileList()
{
	unsigned char result;
	char scmd[3];
	strcpy(scmd, "L\r");
	result = execute_command(scmd, NOTIFY);
	return result;
}
//overload fileList that accepts a file mask
unsigned char Mstor::fileList(char * smask)
{
  unsigned char result;				//this command sends 'L'  to initiate a file-list command using the provided file mask
  char scmd[40];					//after this list is opened, the read-records function will return individual records
  strcpy(scmd, "L");
  strcat(scmd, smask);
  strcat(scmd, "\r");				//Mstor commands end with CR
  result = execute_command(scmd, NOTIFY);	//until a zero-record is returned
  return result;
}

unsigned char Mstor::dirList(char * smask)
{
  unsigned char result;
  char scmd[40];					//after this list is opened, the read-records function will return individual records
  strcpy(scmd, "D");
  strcat(scmd, smask);
  strcat(scmd, "\r");												//send the 'D' command with mask to generate a list of directories
  result = execute_command(scmd, NOTIFY);		//after list opened the read_records function returns individual records
  return result;								//until a zero-record is returned
}

unsigned char Mstor::getVersion()
{
	unsigned char result;
	char scmd[3];
	strcpy(scmd, "V\r");
	result = execute_command(scmd, NOTIFY);
	return result;
}

unsigned char Mstor::setCmdTimeout(char * stimeout)
{
	unsigned char result;
	char scmd[10];
	unsigned int k;
	result = strlen(stimeout);
	strcpy(scmd, "b");							//the command byte
	strcat(scmd, stimeout);
	strcat(scmd, "\r"); 						//put CR on end of command
	result = execute_command(scmd, NOTIFY);
	if (result == NO_ERROR) 					//driver timeout is 20% greater than Mstor
	{											//see manual.  So when updating Mstor timeout
		k = atol(stimeout);						//re-adjust local timeout
		timeout_ms =  k + k/5;
	}
	return result;
}

unsigned char Mstor::getCmdTimeout()
{
	unsigned char result;
	char scmd[3];
	strcpy(scmd, "b\r");				//with no parameter, it returns the current Mstor timeout as ecimal string
	result = execute_command(scmd, NOTIFY);
	return result;
}

unsigned char Mstor::getMode()
{
	unsigned char result;
	char scmd[3];
	strcpy(scmd, "m\r");
	result = execute_command(scmd, NOTIFY);
	return result;
}

//get up to 32 characters from the current directory string .. starting at the
//specified offset. Data is returned in an array. When less than 32-bytes are
//returned, the end of the directory data has been reached. THere is no null-terminator
//contained in the data.
unsigned char Mstor::getCurrentDir(unsigned char offset)
{
	unsigned char result;
	char scmd[8];
	itoa(offset, &scmd[1],  10);		//convert the offset to a string
	scmd[0] = 'c';			//insert command byte
	strcat(scmd, "\r");		//append {CR} to the command
	result = execute_command(scmd, NOTIFY);
	return result;
}

//this function changes the current directory. The change can be
//relative to the current dir, or if started with \ can be from the root
//each .. moves one level up.
//call the execute_command array overlead so don't have to make a copy of incoming string
unsigned char Mstor::changeDir(char * dirstr)
{
	unsigned char result;
	char scmd[50];
	strcpy(&scmd[1], dirstr);
	scmd[0] = 'C';					//call the array overload of cmd so do not have to make copy dirstr
	strcat(scmd, "\r");
	//MonitorPort.print("C command:"); hexit((unsigned char *)scmd, strlen(scmd));
	//MonitorPort.println();
	result = execute_command(scmd, NOTIFY);
	return result;
}


unsigned char Mstor::getFileSize(char * pathfile)
{
	unsigned char result;
	char scmd[40];
	strcpy(scmd, "G");
	strcat(scmd, pathfile);
	strcat(scmd, "\r");							//Mstor cmds end with CR
	result = execute_command(scmd, NOTIFY);
	return result;

}


//get current time from Mstor
unsigned char Mstor::getTime()
{
	char scmd[3];
	unsigned char result;
	strcpy(scmd, "t\r");
	result = execute_command(scmd, NOTIFY);
	return result;
}

//set Mstor time  in 12-hour string format  "HH:MM:SS:AM"
unsigned char Mstor::setTime(char * timestr)
{
	char scmd[15];
	unsigned char result;
	strcpy(scmd, "t");
	strcat(scmd, timestr);
	strcat(scmd, "\r");
	result = execute_command(scmd, NOTIFY);
	return result;
}


//get current time from Mstor
unsigned char Mstor::getDate()
{
	char scmd[3];
	unsigned char result;
	strcpy(scmd, "d\r");
	result = execute_command(scmd, NOTIFY);
	return result;
}

//set Mstor time  in 12-hour string format  "YYYY-MM-DD"
unsigned char Mstor::setDate(char * datestr)
{
	char scmd[13];
	unsigned char result;
	strcpy(scmd, "d");
	strcat(scmd, datestr);
	strcat(scmd, "\r");
	result = execute_command(scmd, NOTIFY);
	return result;
}

unsigned char Mstor::getClkCal()
{
	char scmd[4];
	unsigned char result;
	strcpy(scmd, "$\r");
	result = execute_command(scmd, NOTIFY);
	return result;
}

unsigned char Mstor::setClkCal(char val)
{
	char scmd[10];
	int i;

	unsigned char result;
	i = val;
	itoa(i, &scmd[1], 10);				//convert signed val to a string
	scmd[0] = 'g';
	strcat(scmd, "\r");
	result = execute_command(scmd, NOTIFY);
	return result;
}

// *********************************************************
//returns the user's elapsed millisecond counter
unsigned int Mstor::get_elapsed_ms()
{
	unsigned int val;
	noInterrupts();					//stop the timer
	val = _elapsed_ms;
	interrupts();
	return val;
}

// *********************************************************
//restarts the user's elapsed millisecond counter
void Mstor::restart_elapsed_ms()
{
	noInterrupts();					//stop the timer
	_elapsed_ms = 0;
	interrupts();
}


// **************************
// **************************
//Private Methods:

//returns mstor's elapsed millisecond counter
unsigned int Mstor::get_mstor_ms()
{
	unsigned int val;
	noInterrupts();					//stop the timer
	val = _mstor_ms;
	interrupts();
	return val;
}

//restarts mstors elapsed millisecond counter
void Mstor::restart_mstor_ms()
{
	noInterrupts();					//stop the timer
	_mstor_ms = 0;
	interrupts();
}


//this returns a CRC for the (unsigned) char array of the format  <CdataKK>
//where < is a frame char, C is the data byte count, KK is the 16-bit CRC MS byte first, and > is the closing
//framing tag.  The KK CRC is not included in the CRC calculaton.
//CRC used is  CRC-16 CCITT-FALSE
unsigned int Mstor::compute_crc(unsigned char * blk, unsigned char blk_size)
{
	unsigned int checkval = 0;
	unsigned char i,k;
	   checkval = 0xFFFF;									//CRC-16CCITT-FALSE
       for (i=0;i<blk_size;i++)
	   {
		 if ((i != blk_size-3) && (i != blk_size-2))		//skip over the two crc bytes in the block, then include the closing bracket
		 {
			 checkval ^= (unsigned int)blk[i] << 8;
			 for (k = 8; k != 0; --k) {
				 if ((checkval & 0x8000) != 0) {
					 checkval = (checkval << 1) ^ 0x1021;
				 }
				 else  checkval <<= 1;
			 }
	 	  }
       }
       return checkval;
}


//after a packet is received, its check-characters must be verified to decide whether to accept it and
//extract its data,  or to request a re-transmission of the block.

unsigned char Mstor::validate_packet(unsigned char * buf, unsigned char count)
{
	unsigned int checkval;						//computed CRC
	unsigned int block_check;					//2-byte binary CRC extracted from the incoming block
	unsigned char result = false;				//initially assume CRC fails

	checkval = compute_crc(buf, count);
	block_check = ((unsigned int)buf[count-3]) << 8;		//set upper byte of the incoming check chars
	block_check = block_check  | buf[count-2];				//combine in the lower byte
	if (checkval == block_check) result = true;
	return result;
}




//extract the error code from the NAK array of bytes presented.
//strings will be  [NAK]E-xx  where xx is a string of two decimal
//characters. If xx is not found, return GENERAL_ERROR
unsigned char Mstor::extract_error(unsigned char * nakstr)
{
	nakstr[5] = 0;							//make it null term string for atio function
	unsigned char ecode = GENERAL_ERROR;
	int i;
	i = atoi((const char *)&nakstr[3]);					//extract the ascii code into an integer
	if (i < END_OF_ERRORS) ecode = i;
	return ecode;
}



//see if the initial response to an MSTOR command is an ACK-blk ..
//return 0 for good, or an MSTOR error code.  This can use a fairly short timeout
//period because we are not waiting for full command execution .. just this
//very small 6-byte block  <C{ACK}KK>  that is issued soon after command acceptance
unsigned char Mstor::check_for_ACK(unsigned int timeout)
{
	unsigned char result = GENERAL_ERROR;
	result = get_single_packet_response(timeout, false);     //get  ACK-block (do not put in data  buffer -- no notify host)

	if (_packet_count == 6 && _packet[2] == ACK) result = 0;
	else
	{
		if (_packet_count == 10 && _packet[2] == NAK)
		{
			_packet[7] = 0;			//make the error code look like null term string
			result = atoi((char *)&_packet[5]);		//extract the error code from the packet
		}
	}
	return result;
}


/*  this is the old one that did not contain retries
//this receives exactly one packet, or times out trying.
//this interaction should be short because the amount of data is short.
//can set this timeout at much less for single-block return commands.
unsigned char Mstor::get_packet(unsigned int timeout)
{
	unsigned char last_char;
	unsigned char recv_blocksize=0;
	unsigned char error = NO_ERROR;
	unsigned char pkt_complete = false;

	restart_mstor_ms();
	_packet_count = 0;
	while ((get_mstor_ms() < timeout) && (pkt_complete == false))
	{
		if (get_recv_buf_count() > 0)					//any mstor serial chars received?
		{
			last_char = get_serial_char();				//if so read one
			if (_packet_count < sizeof(_packet))				//safety catch  .. cannot be larger than max mpacket size
			{
				_packet[_packet_count++] = last_char;		//save the incoming char into the block buffer
				if (_packet_count == 2) recv_blocksize = last_char;	//2nd byte of packet is the num data chars
				if (_packet_count >= (recv_blocksize + 5))		//if block is complete?, validate it
				{
					pkt_complete = true;							//block is done we are going to return
					if (validate_packet(_packet, _packet_count) == false)		//block is bad set error. If good, leave at 0
						error = INVALID_PACKET;
				}
			}
			else
			{
				pkt_complete = true;
				error = INVALID_PACKET;
			}
		}
	}

	if (pkt_complete == false) error = COMMAND_TIMEOUT;
	return (error);
} */


//this receives exactly one packet, or times out trying. This interaction should be short because the amount of data is short.
//On ANY error -- timeout or failed validation, it sends a 'rp' (read previous') command to Mstor to request the same packet
//again.  It will do this up to 3 times before trowing in the towel and returning an error.
//Packets can be received with NO retries such as response to a command .. all commands that do not return repetetive data.
//Packets can be received WITH retries such as read a file, list files/dirs, or get current directory string
unsigned char Mstor::get_packet(unsigned int timeout, unsigned char allow_retry, char retry_cmd)
{
	unsigned char last_char;
	unsigned char recv_pktsize=0;
	unsigned char error = INVALID_PACKET;
	unsigned char pkt_complete;
	unsigned char num_retries = 0;
	#define MAX_PACKET_RETRIES 4
	unsigned char allowed_retries = 1;						//use this for packet with no retries
	unsigned char fcmd[10];									//if have to re-request the packet, build the framed 'retry' command here
	static unsigned int pcount = 0;		//****** test only to test clobbered packets and re-transmission
	static unsigned int total_errors = 0;

	if (allow_retry) allowed_retries = MAX_PACKET_RETRIES;	//use this for a packet than can be retried
	while (error == INVALID_PACKET && num_retries < allowed_retries)		//stay in this loop til no error, or max tries exhausted
	{
		pkt_complete = false;
		restart_mstor_ms();													//restart the timer for each attempt to receive packet
		_packet_count = 0;													//total number bytes received this packet
		while ((get_mstor_ms() < timeout) && (pkt_complete == false))		//loop here for each iteration
		{
			if (get_recv_buf_count() > 0)								//any mstor serial chars received?
			{
				last_char = get_serial_char();							//if so read one
				if (_packet_count < sizeof(_packet))					//safety catch  .. cannot already have received max mpacket size
				{
					_packet[_packet_count++] = last_char;		//save the incoming char into the packet buffer
					if (_packet_count == 2) recv_pktsize = last_char;	//2nd byte of packet is the num data chars
					if (_packet_count >= (recv_pktsize + 5))			//if pkt is complete?, validate it
					{
						pkt_complete = true;							//mark packet as 'done'
						#ifdef INJECT_ERRORS							//the injects errors so can see them being corrected
						   pcount++;
						   if (pcount > 5 && pcount % 50 == 0)	_packet[7] = 0;		//clobber every 50th packet as a test
						#endif
						if (validate_packet(_packet, _packet_count) == true) error = NO_ERROR;	//if good, clear error - no more repeat iterations
						else
						{
							num_retries++;
							#ifdef SHOW_ERRORS
								MonitorPort.write("********* BAD!");
								hexit(_packet, _packet_count);
								MonitorPort.println();			//show the bad one for testing only
							#endif
						}
						//if (recv_pktsize == 0) { MonitorPort.write("total errors="); MonitorPort.println(total_errors);}

					}
				}
				else
				{
					num_retries++;
					pkt_complete = true;
				}
			}
		}
		if (pkt_complete == false) num_retries++;						//if not complete, this packet timed out .. so request it again
		if (error != NO_ERROR  && num_retries < MAX_PACKET_RETRIES)		//should we re-request the packet??
		{
			build_framed_retry_cmd(fcmd, retry_cmd);			//works with 'l' or 'r' or 'c' commands that receive repeated data packets
			#ifdef SHOW_ERRORS
				MonitorPort.write("retry cmd=");
				hexit(fcmd, 9);
				MonitorPort.println();
				MonitorPort.println();
				total_errors++;
			#endif
			flush_recv_buffer();
			send_serial_array(fcmd, 9);	  				//send to MSTOR as array (may contain embedded nulls). Repeat requests always 8 bytes
		}												// example:  <C&rp{CR}KK>  len=9  .. format to repeat a record-read
	}
	return (error);
}

//for the moment just used to send request for re-transmission. Can request retry for 'r' or 'l' or 'c' commands, so have to pass in
//the kind of repeat command we are requesting
void Mstor::build_framed_retry_cmd(unsigned char * fcmd, char rcmd)
{
	unsigned int checkval;			//need to send framed "&rp"  or "&lp" or "&cp"  (p = previous)

	fcmd[0] = '<';					//1st char of framed command block
	fcmd[1] = 4;					//the 2nd byte of framed is a count of DATA chars .. always 3 for a repeat request
	fcmd[2] = '&';						//mstor requires this lead character for each command
	fcmd[3] = rcmd;						//the command byte  'r' or 'l' or 'c'
	fcmd[4] = 'p';						//we are asking for previous packet (not 'n'ext)
	fcmd[5] = '\r';						//cmd ends with CR
	fcmd[8] = '>';					//framed closing character.  The two positions [5] and [6] are not set
	checkval = compute_crc(fcmd, 9);				//this computes the check val skipping over the check val positions
	fcmd[6] = checkval >> 8;				//stuff in the HIGH byte CRC
	fcmd[7] = checkval & 0xff;				//stuff LOW byte CRC - framed command block is complete and ready to send

}

//this is the single-packet protocol receiver. Receives a single packet which is expected to start with an {ACK} as the first
//data character. If it does, the rest of the data portion is data.  Otherwise it may be just an ACK response.
//If the first data char is a NAK, then this is an error packet .. extract the error and return it.  If the host is to be
//notified, move any received data into the transfer buffer.  Otherwise, internal consumption -- keep it quiet
//When used as the receiver of a single-block command, it alters m_transfer.status,  however when NOT part of a
//single-block  (maybe checkForACK or other where it is part of an ongoing process) it does NOT modify m_transfer.status
//because that larger process manages that.
unsigned char Mstor::get_single_packet_response( unsigned int timeout, unsigned char notify_host)
{
	unsigned char error = NO_ERROR;
	unsigned char i;

	if ((error = get_packet(timeout, NO_PACKET_RETRY, 'x')) == NO_ERROR)	//waits for packet or time out. NO RETRIES, dummy retry cmd='x' <C{ACK}dataKK>  format if the block is received successfully
	{
		if (_packet[2] == ACK)						//we have an 'accepted' response
		{
			if (notify_host)
			{
				for (i=0;i<_packet_count-6;i++) data[i] = _packet[i+3];   //remove framing + {ACK} from count
				data_count = _packet_count -6;
			}
		}
		else
		{
			if (_packet[2] == NAK)
			{
				_packet[7] = 0;					//make the NAKstr look like a string by inserting null termination
				error =  extract_error(&_packet[2]);	//extract the error code from the NAK string .. NAK starts at [2] in the buffer
			}
			else error = GENERAL_ERROR;
		}
	}
	if (notify_host) {
		error_code = error;
		data_count = _packet_count - 6;
	}
	return error;
}


//first check that mstor is connected,  then check that blocksizes match,  then check that we can read the timeout
//return with the first error detected.  If no errors return 0
byte Mstor::init_mstor()
{
	byte result = NO_ERROR;
	int mstor_blocksize;

	unsigned int mstor_timeout = 0;

	mstor_initialized = false;					//disallow disk commands unless initialization suceeds
	result = check_connected();					//see if mstor responds at the port/baud specified
	if (result == NO_ERROR)
	{
		mstor_blocksize = getMstorBlksize();
		if (mstor_blocksize == DATA_SIZE)			//if the two transfer-blocksizes match keep going
		{
			mstor_timeout = get_mstor_timeout();
			if (mstor_timeout >= MIN_TIMEOUT && mstor_timeout <= MAX_TIMEOUT)
			{
				timeout_ms = mstor_timeout + mstor_timeout/5;		//driver's timeout is always 20% larger than Mstor's
				mstor_initialized = true;							//to guarantee Mstor response occurs within driver timeout period
			}
			else
			{
				result = INVALID_TIMEOUT;
				#ifdef DEBUG
				  MonitorPort.print(F("Timeout Setting -"));
				  MonitorPort.println(mstor_timeout);
				#endif
			}
		}
		else
		{
			result = BLOCK_SIZES_DO_NOT_MATCH;
			#ifdef DEBUG
			 MonitorPort.print(F("Mstor blksize= ")); MonitorPort.println(mstor_blocksize);
			 MonitorPort.print(F("Arduino _packet ")); MonitorPort.println(sizeof(_packet));
			#endif
		}
	}
	else result = MSTOR_NOT_FOUND;
	return result;
}

//see if mstor is connected return true if connected.  DO NOT SEND A BLOCK COMMAND since we don't yet know if the check-style of the
//driver matches MSTOR.  Send a naked command (MSTOR will execute it and return data ... receive it here so it is NOT block-validated
//this will inform if MSTOR is there and talking a matching baud rate.
unsigned char Mstor::check_connected()
{
	unsigned char result = NO_ERROR;
  	char scmd[5];
  	byte i;

	mstor_connected = false;
	_packet_count = 0;				//count received characters
  	strcpy(scmd, "&V\r");
	send_serial_string(scmd);			//send this naked command .. no block formatting. Mstor will respond

	i = get_single_packet_response(250,false);		//get the 1-packet response

//hexit(data, data_count);
	if (i == NO_ERROR && _packet_count >= 12)
	{
		_packet[_packet_count-3] = 0;					//make the response look like a null term string  <C{ACK}MSTORv1.xxKK>
		if (strstr((char *)&_packet[2], "MSTOR") == NULL) result = MSTOR_NOT_FOUND;		//see if it returned MSTOR.  If so, we are good
		else
		{
			strcpy(mstor_version, (char *)&_packet[3]);
			mstor_connected = true;
		}
	}
	else result = INVALID_PACKET;
	return result;
}

//this changes the Mstor baud rate. Once the command is issued, the caller should wait (up to 10ms) for a valid reponse at the
//previous baud rate. If success the caller should change their baud rate and continue communications.
//If an error is returned, the baud is NOT changed and the caller should remain at the previous baud rate
unsigned char Mstor::set_mstor_baudrate(unsigned char baud)
{
	unsigned char result = NO_ERROR;
	char scmd[5];
	char baudstr[2];						//  0   1    2    3    4     5     6      7     8    9
	if (baud >= 0 && baud <= 9)				//1200,2400,4800,9600,19.2k,38.4k,57.6k,115.2k,250k,500k
	{
		baudstr[0] = baud + '0';			//convert to an ASCII char
		baudstr[1] = 0;						//tack on null termination to make a string
		strcpy(scmd, "E");
		strcat(scmd, baudstr);
		strcat(scmd, "\r");						//add command terminator

		result = execute_command(scmd, NOTIFY);
	}
	else result = INVALID_PARAMETER;
	return result;
}


//this is not a user command .. it is private.  So does not return a reslut=0/error code like other methods.
//it returns an integer.  And it is not actually the Mstor blocksize ... it is the data_size  which is
//blocksize -5.  Blocksize is invoncenient for users ... they want to deal with the number of data bytes
//and don't care about the background framing that is included in blocksize.
int Mstor::getMstorBlksize()
{
	int result = 0;
  	char scmd[5];
  	byte i;

  	strcpy(scmd, "&B\r");
	send_serial_string(scmd);			//send this naked command .. no block formatting. Mstor will respond
	i = get_single_packet_response(timeout_ms, NOTIFY);
	if (i == NO_ERROR && _packet_count >= 5)
	{
		for (i=0;i<_packet_count-6;i++) {					//make the response look like a null term string  <C{ACK}MSTORv1.xxKK>
		   scmd[i] = _packet[i+3];
		}
		scmd[i] = 0;										//make it null terminated
		result = atoi(scmd) - 5;
	}
	return result;
}


//this sets the Mstor blocksize  (which is 5 bytes larger than the Arduino Data Size because i it includes framing.)
//the value is passed as the string equivalent of the block size
unsigned char Mstor::setBlocksize(char * bsize)
{
	int result = 0;
	char scmd[7];
	byte i;

	strcpy(scmd, "&B");
	strcat(scmd, bsize);
	strcat(scmd, "\r");
	send_serial_string(scmd);			//send this naked command .. no block formatting. Mstor will respond
	result = get_single_packet_response(timeout_ms, NOTIFY);
	return result;
}

unsigned char Mstor::setPower(char * pstr)
{
	char scmd[5];
	unsigned char result;
	strcpy(scmd, "P");
	strcat(scmd, pstr);
	strcat(scmd, "\r");							//must end with CR for Mstor
	result = execute_command(scmd, NOTIFY);
	return result;
}


unsigned char Mstor::getPower()
{
	char scmd[5];
	unsigned char result;
	strcpy(scmd, "P\r");
	result = execute_command(scmd, NOTIFY);
	return result;
}

unsigned int Mstor::get_mstor_timeout()
{
	long lresult = 0;
	unsigned int iresult = 0;
  	char scmd[8];
  	byte i;

  	strcpy(scmd, "&b\r");
	send_serial_string(scmd);			//send this naked command .. no block formatting. Mstor will respond
	i = get_single_packet_response(timeout_ms, false);
	if (i == NO_ERROR && _packet_count >= 6)
	{
		for (i=0;i<_packet_count-6;i++) 					//make the response look like a null term string  <C{ACK}MSTORv1.xxKK>
		   scmd[i] = _packet[i+3];
		scmd[i] = 0;										//make it null terminated
		lresult = atol(scmd);						//to get unsigned int have to use long
		iresult = lresult;
	}
	return iresult;
}

unsigned char Mstor::fileDelete(char * pathfile)
{
	char scmd[40];
	unsigned char result;
	strcpy(scmd, "F");
	strcat(scmd, pathfile);
	strcat(scmd, "\r");						//Mstor commands end with CR
	result = execute_command(scmd, NOTIFY);
	return result;
}

unsigned char Mstor::fileRename(char * oldname, char * newname)
{
	char scmd[50];
	unsigned char result;
	strcpy(scmd, "N");
	strcat(scmd, oldname);
	strcat(scmd, ">");
	strcat(scmd, newname);
	strcat(scmd, "\r");						//Mstor commands end with CR
	result = execute_command(scmd, NOTIFY);
	return result;
}

unsigned char Mstor::makeDir(char * pathfile)
{
	char scmd[50];
	unsigned char result;
	strcpy(scmd, "M");
	strcat(scmd, pathfile);
	strcat(scmd, "/r");
	result = execute_command(scmd, NOTIFY);
	return result;
}

unsigned char Mstor::deleteDir(char * pathfile)
{
	char scmd[50];
	unsigned char result;
	strcpy(scmd, "K");
	strcat(scmd, pathfile);
	strcat(scmd, "\r");
	result = execute_command(scmd, NOTIFY);
	return result;
}

unsigned char Mstor::testBattery()
{
	char scmd[4];
	unsigned char result;
	strcpy(scmd, "Y\r");
	result = execute_command(scmd, NOTIFY);
	return result;
}

//check to see if the command is a disk-command.  Do not allow if initialization was not successful
unsigned char isDiskCommand(char cmd)
{
	unsigned char i;
	const char disk_commands[] = {'W','A','R','S','M','K','L','D','C','F','N','G','e','l','c','r','n','y'};	 //fails if put in .h file??

	unsigned char result = false;
	for (i=0;i<sizeof(disk_commands);i++)
	{
		if (cmd == disk_commands[i])
		{
			result = true;
			break;
		}
	}
	return result;
}

//this is an overload of the execute_command method.  Allows users to pass in strings instead of arrays.
//All string commands must be terminated with a CR!!
//having the array version is necessary so can send byte-data containing nulls.
unsigned char Mstor::execute_command(char * mstor_str, unsigned char notify_host)
{
	unsigned char result = NO_ERROR;
	unsigned char cmdlen;
	char cmd_byte;												//separate the command byte so compatible with sending a byte-array

	cmd_byte = mstor_str[0];
	if (!isDiskCommand(cmd_byte) || mstor_initialized)							//disk commands require successful initialization
	{
		cmdlen = strlen(mstor_str) -1;											//the length of the remainder of the command
		if (cmdlen > MAX_CMD_LENGTH) result = COMMAND_TOO_LONG;					//limit string size for Arduino memory
		if (result == NO_ERROR)
		{
		//make the arriving string look like an array .. and pass its length
			result = execute_command(cmd_byte, (unsigned char *)&mstor_str[1], cmdlen, notify_host);	//call the overloaded version that handles an array
		}
	}
	else result = INITIALIZATION_FAILED;
	return result;
}

//issue .. I need to have the entire command in a buffer so the CRC generator can run on it.   But commands can
//be 45 chars long.  Would prefer not to allocate a new buffer here (even as auto-variable)
//that uses a lot of RAM that a small computer might not have.  At the moment do not see any way around it.
//This overload of 'execute_command'  takes an array .. so can accept embedded nulls in the command

unsigned char Mstor::execute_command(char cmd, unsigned char * cmdarray, unsigned char count, unsigned char notify_host)		//notify host lets comands be used for internal consumption
{
unsigned char ecode;
unsigned int checkval;
unsigned char i;
unsigned char framed_cmd[MAX_CMD_LENGTH + 8];			//commands are like ... <C&w .. 45-string len ..{CR}{KK>   = 4 lead, 45 data, 1 CR and 3 trail = 53
														//gets framed to  <C&RDD..DD{CR}KK>  (ads 3 to front, 3 to back .. so +8
														//to pass an array .. make user  utilize Mstor.data[] which is max 32 bytes
 if (mstor_connected == false) return MSTOR_NOT_FOUND;	//user MUST have run init_mstor_driver() and mstor had to be found
  ecode = NO_ERROR;
  // cmd_len = strlen(mstor_cmd);					//incoming len required. Once CRC added it is binary array -crc may have nulls
  //Mstor commands require an & to preceded the command byte.  Do not want to insert it into the string because that would alter
  //the string presented. Instead, just insert the ampersand into the command block being built, and adjust cmd_len to account for
  //the extra character

  	if (count > MAX_CMD_LENGTH) return(COMMAND_TOO_LONG);

  	framed_cmd[0] = '<';						//1st char of framed command block
	//framed_cmd[1] = cmd_len;					//the 2nd byte of a framed block is a count of DATA chars contained only (INCLUDING the inserted &)
	framed_cmd[2] = '&';						//mstor requires this lead character for each command -- (it extends the length by +1)
	framed_cmd[3] = cmd;						//the command byte
	for (i=0;i<count;i++) framed_cmd[i+4] = (unsigned char)cmdarray[i];		//moved the provided array into the larger framed array
	count += 2;									//we bumped the size of the array by 2 by adding the '&' and cmd byte to the data payload
	framed_cmd[1] = count;					//insert 2nd byte of the command block as block length including the added & char
	framed_cmd[count + 4] = '>';			//block frame closing character.  The two positions cmd_len+2 and cmd_len+3 (checkval) are not set
	checkval = compute_crc(framed_cmd, count + 5);				//this computes the check val skipping over the check val positions
	framed_cmd[count + 2] = checkval >> 8;
	framed_cmd[count + 3] = checkval & 0xff;				//framed command block is complete and ready to send
	flush_recv_buffer();						//clear out any junk left in receive buffer

 //hexit(framed_cmd, count +5);
	send_serial_array(framed_cmd, count + 5);	  //send it to MSTOR as array (may contain embedded nulls), pause if buf fills, cmd may be long

	switch (cmd)               	 //different command classes have different actions
	{
		case 'R':							//open a file for reading
		case 'W':							//open a file for writing
		case 'A':							//open a file to append
		case 'S':							//open a file to seek
		case 'b':							//get/set timeout
		case 'C':							//change MSTOR directory
		case 'c':							//get up to 32 chars of current directory starting at offset
		case 'F':							//delete a file
		case 'G':							//get filesize
		case 'K':							//delete directory
		case 'M':							//make a directory
		case 'L':							//list files
		case 'D':							//list dirs
		case 'N':							//rename a file
		case '$':							//get current clock calibration value
		case 'g':							//clock calibration
		case 'P':							//power disk up/down/report
		case 'B':							//get/set blocksize
		case 't':							//get-set clock time  returns  {ACK}10:23:45AM  = 11 data chars = 15 frame chars
		case 'd':							//get-set clock date
		case 'm':							//get command mode
		case 'e':							//close a file
		case 'w':							//write a record to a file
		case 'V':							//get Mstor code version
		case 'E':							//set baud rate
		case 'Y':							//test battery
			ecode = get_single_packet_response(timeout_ms, notify_host);
		break;
		case 'y':							//copy a file
		case 'n':							//concat files
			ecode = get_single_packet_response(2500, NOTIFY);			//mstor must return an ACK blk .. might take longer if files are big so boost timeout
		break;
		case 'l':
		case 'r':									//read a single record .. from a file or from a filelist, or directory record
			ecode = get_packet(timeout_ms, PACKET_RETRY, cmd);	//and allow retry of the packet on failure. cmd is the retry-type 'r' or 'l' or 'c' to send if needed
			data_count = _packet_count -5;
			for (i=0;i<data_count;i++)
			{
				data[i] = _packet[i+2];
			}
			if (error_code == 0)
			{
				if (_packet[2] == NAK && _packet_count == 10)
				{
					_packet[7] = 0;					//make the NAKstr look like a string by inserting null termination
					ecode =  extract_error(&_packet[2]);	//extract the error code from the NAK string .. NAK starts at [2] in the buffer
				}
			}
		break;
		default:
		   ecode = BAD_COMMAND;
		break;
 }
 return ecode;
}




//Method must be run in a 2-25ms timer to keep millisecond timers updated
void Mstor::run_ms_timer()
{
	_elapsed_ms += _ms_per_tick;			//bump the elapsed ms timer
	_mstor_ms += _ms_per_tick;				//bump the internal elapsed ms timer
}


// ************************  Serial Comm Methods *************************
// These functions are not part of the Mstor class

byte get_serial_char()
{
	byte c = 0;
	if (MstorPort.available())  c = MstorPort.read();
}

unsigned char get_xmit_buf_available()		//see if there are any there
{
	unsigned char ch;
	noInterrupts();				//DISABLE_RXINTS;
	ch =  MstorPort.availableForWrite();				//return the number
	interrupts();				//ENABLE_RXINTS;
	return ch;
}

unsigned char get_recv_buf_count()
{
  unsigned char ch;
  ch = MstorPort.available();
  return ch;
}

void flush_recv_buffer()
{
	  while (MstorPort.available()) get_serial_char();    // flush receive buffer function
}

void send_serial_char(unsigned char val)
{
	unsigned int port_timer = 0;
	//while ((MstorPort.availableForWrite() == 0)  && (port_timer++ < 2000))		//do not wait forever
 	MstorPort.write(val);
}

void send_serial_string(char * sval)		//stuff string of characters into the transmit buffer
{
unsigned char i = 0;
	while (sval[i] != 0)
	{
		send_serial_char(sval[i++]);
	}
}


void send_serial_array(unsigned char * sval, unsigned char length)		//stuff array of bytes into the transmit buffer
{							//WAIT if necessary for space to become available
unsigned char i=0;

	while (i < length)
	{
		send_serial_char(sval[i++]);
	}
}


void Mstor::hexit(unsigned char * str, unsigned char count)
{

  char hexChars[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
  unsigned char i;
  unsigned char k = 0;
  unsigned char len;
  unsigned char temp[5];       //may need this to create [xx]  sequence
  for (i = 0; i < count; i++)   //go thru each char
  {
    if (str[i] >= 0x20 && str[i] < 0x7f) MonitorPort.write(str[i]);  //if printable, print
    else
    {
      k = 0;                                //non-printable, build [xx] string
      temp[k++] = '[';
      len = 4;
      switch (str[i])
      {
        case ACK:
          temp[k++] = 'A';  temp[k++] = 'C'; temp[k++] = 'K'; len = 5;
          break;
        case NAK:
          temp[k++] = 'N'; temp[k++] = 'A'; temp[k++] = 'K'; len = 5;
          break;
        case CARET:
          temp[k++] = 'C'; temp[k++] = 'R';
          break;
        default:
          temp[k++] = hexChars[(str[i] / 16)];
          temp[k++] = hexChars[str[i] % 16];
          break;
      }
      temp[k++] = ']';
      MonitorPort.write(temp, len);            //print the [xx] string
    }
  }

}